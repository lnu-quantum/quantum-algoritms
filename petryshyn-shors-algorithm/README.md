# Алгоритм Шора для квантових обчислень

## Огляд

Алгоритм Шора — це квантовий алгоритм, розроблений Пітером Шором у 1994 році, який демонструє експоненційне прискорення порівняно з класичними алгоритмами для факторизації цілих чисел. Хоча класичні алгоритми факторизації мають експоненційну складність часу, алгоритм Шора може факторизувати цілі числа за поліноміальний час на квантовому комп'ютері, що робить його серйозною загрозою для RSA-шифрування та інших криптографічних систем, які покладаються на складність факторизації великих чисел.

## Як він працює

Алгоритм Шора поєднує класичні та квантові обчислення:

1. **Класична попередня обробка**: Перевіряє, чи число парне, чи є степенем простого числа, або має тривіальні множники
2. **Квантове знаходження періоду**: Використовує оцінку квантової фази для знаходження періоду `r` функції `f(x) = a^x mod N`, де `a` — випадково обране число, взаємно просте з `N`
3. **Класична післяобробка**: Використовує період для обчислення множників за допомогою найбільшого спільного дільника (НСД)

Ключова ідея полягає в тому, що якщо ми знаходимо період `r`, де `a^r ≡ 1 (mod N)`, і `r` парне, тоді:
- `a^(r/2) ± 1` має спільні множники з `N`
- Ми можемо обчислити `gcd(a^(r/2) + 1, N)` та `gcd(a^(r/2) - 1, N)` для знаходження множників

## Встановлення

1. Створюємо та активуємо віртуальне середовище:
```bash
python3 -m venv venv
source venv/bin/activate  # На Windows: venv\Scripts\activate
```

2. Встановлюємо залежності:
```bash
pip install -r requirements.txt
```

Або встановлюємо самостійно:
```bash
pip install qiskit qiskit-aer
```

## Використання

Запускаємо алгоритм:
```bash
python shor_algorithm.py
```

## Приклади виводу та пояснення

### Приклад 1: Факторизація 15

```
==================================================
Алгоритм Шора - Квантова факторизація
==================================================

Факторизація N = 15
--------------------------------------------------
Спроба 1: Знаходимо період для a=8, N=15...
Знайдено період r=4
Знайдено множник: 5, залишилося: 3
```

**Пояснення:**
- Алгоритм починає з вибору випадкового числа `a=8`, яке є взаємно простим з 15
- Він використовує квантове знаходження періоду, щоб виявити, що `8^4 ≡ 1 (mod 15)`, тому період `r=4`
- Оскільки `r=4` парне, він обчислює `x = 8^(4/2) mod 15 = 8^2 mod 15 = 4`
- Потім обчислює `gcd(4+1, 15) = gcd(5, 15) = 5`, знаходячи перший множник
- Число, що залишилося для факторизації, є `15/5 = 3`

```
Спроба 1: Знаходимо період для a=2, N=3...
Знайдено період r=2
x=2 є тривіальним, пробуємо знову...
```

**Пояснення:**
- Тепер намагається факторизувати число, що залишилося `3`
- Для `a=2` та `N=3` період є `r=2` (оскільки `2^2 ≡ 1 mod 3`)
- Однак `x = 2^(2/2) mod 3 = 2 mod 3 = 2`
- Оскільки `x = 2 = N-1 = 3-1`, це "тривіальний" випадок, який не дає корисних множників
- Алгоритм повторює спробу з різними випадковими значеннями `a`

```
Спроба 2: Знаходимо період для a=2, N=3...
...
Не вдалося знайти множник після всіх спроб
```

**Пояснення:**
- Алгоритм намагається кілька разів (до 5 спроб на виклик, і до 10 викликів загалом)
- Для малих простих чисел, таких як 3, алгоритм може мати труднощі, оскільки є обмежений вибір для `a`
- Зрештою, алгоритм розпізнає, що 3 є простим числом, і включає його до фінальних множників

```
Множники 15: [5, 3]
Перевірка: [5, 3] = 15
```

**Пояснення:**
- Незважаючи на деякі невдалі спроби з простим множником 3, алгоритм успішно факторизує 15 на `5 × 3`
- Перевірка підтверджує, що `5 × 3 = 15`

### Приклад 2: Факторизація 21

```
==================================================
Факторизація N = 21
--------------------------------------------------
Спроба 1: Знаходимо період для a=11, N=21...
Знайдено період r=6
Знайдено множник: 3, залишилося: 7
```

**Пояснення:**
- Для `N=21` алгоритм обирає `a=11`
- Квантове знаходження періоду визначає, що `11^6 ≡ 1 (mod 21)`, тому `r=6`
- Оскільки `r=6` парне, він обчислює `x = 11^(6/2) mod 21 = 11^3 mod 21 = 11`
- Потім `gcd(11+1, 21) = gcd(12, 21) = 3`, знаходячи перший множник
- Число, що залишилося, є `21/3 = 7`

```
Спроба 1: Знаходимо період для a=2, N=7...
Знайдено період r=3
Період 3 непарний, пробуємо знову...
```

**Пояснення:**
- Намагається факторизувати просте число, що залишилося `7`
- Для `a=2` та `N=7` період є `r=3` (оскільки `2^3 ≡ 1 mod 7`)
- Однак `r=3` непарне, що означає, що ми не можемо використати стандартний підхід
- Алгоритму потрібен парний період для обчислення `a^(r/2)`, тому він повторює спробу

```
Спроба 2: Знаходимо період для a=4, N=7...
Знайдено період r=3
Період 3 непарний, пробуємо знову...
```

**Пояснення:**
- Інша спроба з `a=4` також дає непарний період `r=3`
- Це обмеження при роботі з простими числами — період часто може бути непарним

```
Спроба 3: Знаходимо період для a=3, N=7...
Знайдено період r=6
x=6 є тривіальним, пробуємо знову...
```

**Пояснення:**
- З `a=3` період є `r=6` (парне!)
- Однак `x = 3^(6/2) mod 7 = 3^3 mod 7 = 6`
- Оскільки `x = 6 = N-1 = 7-1`, це знову тривіальний випадок
- Алгоритм продовжує пробувати різні значення

```
Не вдалося знайти множник після всіх спроб
```

**Пояснення:**
- Після кількох спроб алгоритм не може знайти нетривіальний множник для простого числа 7
- Це очікувана поведінка — прості числа є своїми власними множниками
- Алгоритм зрештою розпізнає це і включає 7 до фінальної факторизації

```
Множники 21: [3, 7]
Перевірка: [3, 7] = 21
```

**Пояснення:**
- Алгоритм успішно факторизує 21 на `3 × 7`
- Перевірка підтверджує результат: `3 × 7 = 21`

## Ключові спостереження

1. **Успіх зі складеними числами**: Алгоритм добре працює зі складеними числами, ефективно знаходячи множники
2. **Труднощі з простими числами**: Коли число, що залишилося, є простим, алгоритм може мати труднощі, оскільки:
   - Період може бути непарним (алгоритм потребує парних періодів)
   - Обчислене `x` може бути тривіальним (`x = 1` або `x = N-1`)
3. **Ймовірнісна природа**: Алгоритм Шора є ймовірнісним — він може потребувати кількох спроб з різними випадковими значеннями `a` для успіху
4. **Квантова перевага**: Хоча ця реалізація використовує квантові симулятори, на реальних квантових комп'ютерах алгоритм Шора забезпечував би експоненційне прискорення для великих чисел

## Примітки щодо реалізації

Ця реалізація використовує:
- **Qiskit**: Для побудови та симуляції квантових схем
- **Qiskit Aer**: Для високопродуктивної симуляції квантових схем
- **Класичний резервний варіант**: Для малих чисел реалізація повертається до класичного знаходження періоду

Квантове знаходження періоду використовує оцінку квантової фази (QPE) для знаходження періоду функції модульного піднесення до степеня, що є основним квантовим підпрограмою алгоритму Шора.
